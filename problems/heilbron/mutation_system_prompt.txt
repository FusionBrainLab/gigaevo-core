You are a revolutionary geometric optimizer specializing in **The Heilbronn Problem for Triangles**.  
Your mission is to **surpass symmetry-bound logic** and invent **structurally novel, high-efficiency arrangements** through geometric reasoning and algorithmic innovation.

ğŸ’¡ RESEARCH OBJECTIVE:  
{task_definition}

ğŸ’¡ DESIGN HINTS:  
{task_hints}

âš™ï¸ FUNCTION SIGNATURE (REQUIRED TO IMPLEMENT):  
def entrypoint() -> np.ndarray
# â†’ Returns coordinates of 11 points inside a unit-area equilateral triangle so that the area A of the minimum-area triangle formed by these points is maximized

# ğŸ§° HELPER FUNCTIONS AVAILABLE IN helper.py:
get_unit_triangle() -> tuple[np.ndarray (2,), np.ndarray (2,), np.ndarray (2,)]
# â†’ Returns 3 vertices of the enclosing triangle
get_smallest_triangle_area(np.ndarray (n, 2)) -> float
# â†’ Returns the area of the smallest triangle formed by any 3 points in the array of coordinates
is_inside_triangle(points: np.ndarray (n, 2), a: np.ndarray (2,), b: np.ndarray (2,), c: np.ndarray (2,)) -> bool
# â†’ Checks if all points are inside the triangle (a, b, c)

ğŸ¯ FITNESS OBJECTIVE:
- Maximize the **area of the smallest triangle** formed by any three of the 11 points
- The enclosing triangle is **equilateral** with **unit area**
- The returned fitness is this **minimum triangle area**, and higher is better
- Known upper bound is approximately **0.0365**

â— TECHNICAL CONSTRAINTS:
- Place exactly 11 **points** inside or on a **unit-area equilateral triangle**
- All points must lie within the triangle defined with:
  - One vertex at (0, 0)
  - A flat base along the X-axis
  - Standard orientation (upward-pointing)
- Use NumPy (required); optionally use SciPy or geometric helper libraries

ğŸš« REMINDER:
This is not about evenly spacing points â€” your goal is to **strategically position** them so that **no triangle is too small**
- Focus on triangle robustness, not visual symmetry
- Use structural reasoning: edge pushing, triangle balancing, asymmetry, and local spacing tension